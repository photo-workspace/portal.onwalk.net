#!/usr/bin/env node

const { spawn } = require("node:child_process");
const fs = require("node:fs");
const os = require("node:os");
const path = require("node:path");

const args = process.argv.slice(2);

const env = {
  ...process.env,
  NODE_ENV: process.env.NODE_ENV ?? "production",
  ENABLE_LOCAL_MEDIA_FALLBACK:
    process.env.ENABLE_LOCAL_MEDIA_FALLBACK ?? "false",
};

const isEnabled = (value) => {
  if (!value) {
    return false;
  }

  return value === "1" || value.toLowerCase() === "true";
};

const buildMcpConfig = () => {
  const sections = [];

  if (isEnabled(env.ENABLE_GITHUB_MCP)) {
    sections.push(
      `[mcp_servers.github]\nurl = "https://api.githubcopilot.com/mcp/"\nbearer_token_env_var = "CODEX_GITHUB_PERSONAL_ACCESS_TOKEN"`,
    );
  }

  if (isEnabled(env.ENABLE_Chrome_devtools_MCP)) {
    const host = env.CHROME_DEBUGGING_HOST ?? "127.0.0.1";
    const port = env.CHROME_DEBUGGING_PORT ?? "9222";
    sections.push(
      `[mcp_servers.chrome-devtools]\n` +
        `type = "stdio"\n` +
        `command = "npx"\n` +
        `args = ["-y", "chrome-devtools-mcp@latest", "--browser-url=http://${host}:${port}"]\n` +
        `startup_timeout_sec = 10`,
    );
  }

  if (isEnabled(env.ENABLE_Next_devtools_MCP)) {
    sections.push(
      `[mcp_servers.next-devtools]\n` +
        `type = "stdio"\n` +
        `command = "npx"\n` +
        `args = ["-y", "next-devtools-mcp@latest"]\n` +
        `startup_timeout_sec = 30`,
    );
  }

  if (sections.length === 0) {
    return "# Generated by scripts/start.js\n";
  }

  return `# Generated by scripts/start.js\n\n${sections.join("\n\n")}\n`;
};

const writeMcpConfig = (filePath, content) => {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });

  const sectionsText = content
    .replace(/^# Generated by scripts\/start\.js\n?\n?/, "")
    .trim();
  if (!sectionsText) {
    return;
  }

  const sections = sectionsText.split(/\n\n+/);
  const existing = fs.existsSync(filePath)
    ? fs.readFileSync(filePath, "utf8").trimEnd()
    : "";
  const newSections = sections.filter((section) => {
    const header = section.split("\n")[0];
    return !existing.includes(header);
  });

  if (newSections.length === 0) {
    return;
  }

  const appended = newSections.join("\n\n");

  if (!existing) {
    fs.writeFileSync(
      filePath,
      `# Generated by scripts/start.js\n\n${appended}\n`,
      "utf8",
    );
    return;
  }

  fs.writeFileSync(filePath, `${existing}\n\n${appended}\n`, "utf8");
};

try {
  const config = buildMcpConfig();
  const repoConfigPath = path.join(process.cwd(), ".opencode", "config.toml");
  const homeConfigPath = path.join(os.homedir(), ".opencode", "config.toml");
  writeMcpConfig(repoConfigPath, config);
  writeMcpConfig(homeConfigPath, config);
} catch (error) {
  console.warn("[MCP] Failed to update opencode config:", error);
}

const child = spawn("next", ["start", ...args], {
  stdio: "inherit",
  shell: process.platform === "win32",
  env,
});

child.on("error", (error) => {
  console.error("Failed to launch Next.js:", error);
  process.exit(1);
});

child.on("close", (code, signal) => {
  if (signal) {
    process.kill(process.pid, signal);
  } else {
    process.exit(code ?? 0);
  }
});
